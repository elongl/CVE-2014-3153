# Towelroot
> The futex_requeue function in kernel/futex.c in the Linux kernel through 3.14.5 does not ensure that calls have two different futex addresses, which allows local users to gain privileges via a crafted FUTEX_REQUEUE command that facilitates unsafe waiter modification.

---

## Kernel Crash
- [Parent] Locking the PI-aware futex. In userspace, atomically overwrite futex with the ownerâ€™s TID.
- [Child] Wait on a non-PI futex, and later requeue to a PI-aware futex.  
    - Create a futex queue entry and set its members to point to the stack variables.
    ```c
    struct futex_q q = futex_q_init;
    q.bitset = bitset;
    q.rt_waiter = &rt_waiter;
    q.requeue_pi_key = &key2;
    ```
    - Enqueue the futex queue entry (`futex_q`) onto the `futex_hash_bucket`.
    - Call `schedule()` and wait for the task to be flagged for rescheduling (sleep meanwhile).
- [Parent] Requeue the non-PI futex to the PI-aware futex.
    - Enqueue the `rt_mutex_waiter` to the `rt_mutex`.
    ```c
    plist_add(&waiter->list_entry, &lock->wait_list);
    ```
    - Requeue the futex queue entry to the destination futex bucket.
    ```c
    plist_del(&q->list, &hb1->chain);
	plist_add(&q->list, &hb2->chain);
    ```
- [Parent] Overwrite `pi_futex` with `0` in userspace (Manual Unlock).
```c
*pi_futex = 0;
```
- [Parent] Requeue the PI-aware futex to itself.
    - Take the lock on `pi_futex`.
    ```c
    if (unlikely(cmpxchg_futex_value_locked(&curval, uaddr, 0, newval)))
        return -EFAULT;

    ...

    /*
	 * Surprise - we got the lock. Just return to userspace:
	 */
	if (unlikely(!curval))
		return 1;
    ```
    - Wake up the child task.  
    `futex_wait_requeue_pi` exits without deleting `rt_waiter` from the `rt_mutex.wait_list`.  
    Kernel stack is overwritten and `rt_waiter` now points to garbage memory.  
    **Note**: The problem here is that the task should only wake up either because:
      - The lock was acquired, in which case `rt_waiter` is `NULL` and had already been removed from the `rt_mutex.wait_list`.
      - The lock was unlocked or the timeout was reached, which should issue the cleanup.

      Here, neither happens. Instead, the task wakes up and it wasn't removed from the waiters list on `rt_mutex`.
    ```c
    ret = futex_lock_pi_atomic(pifutex, hb2, key2, ps, top_waiter->task,
				   set_waiters);
	if (ret == 1)
		requeue_pi_wake_futex(top_waiter, key2, hb2); // <-- Wakeup
    ```


## Notes
- Add a `printk()` at each point within the flow.  
  Make sure the data changes accordingly in order to assess the control flow.
- Critical functions:
    - `futex_lock_pi`
    - `rt_mutex_start_proxy_lock`
    - `requeue_pi_wake_futex`
    - `requeue_futex`
